@using IntelliTect.Coalesce.CodeGeneration.Templating.Razor;
@using IntelliTect.Coalesce.CodeGeneration.Knockout.Generators;
@using IntelliTect.Coalesce.TypeDefinition
@using IntelliTect.Coalesce.Utilities
@inherits CoalesceTemplate<ClassDto>
@{
    ClassViewModel model = Model.Model;
    string namespaceName = Model.Namespace;
    if (!string.IsNullOrWhiteSpace(Model.AreaName))
    {
        namespaceName += "." + Model.AreaName;
    }

    var namespaces = new List<string>();
    namespaces.Add("IntelliTect.Coalesce.Interfaces");
    namespaces.Add("IntelliTect.Coalesce.Mapping");
    namespaces.Add("IntelliTect.Coalesce.Models");
    namespaces.Add("IntelliTect.Coalesce.Helpers.IncludeTree");
    namespaces.Add("Newtonsoft.Json");
    namespaces.Add("System");
    namespaces.Add("System.Linq");
    namespaces.Add("System.Linq.Dynamic.Core");
    namespaces.Add("System.Collections.Generic");
    namespaces.Add("System.Security.Claims");
    namespaces.Add($"{namespaceName}.Models");
}
@foreach (var ns in ReflectionRepository.Global.Namespaces.Where(f => f != "System"))
{
    if (!namespaces.Contains(ns)) { namespaces.Add(ns); }
}
@foreach (var prop in model.ClientProperties)
{
    var ns = prop.Type.PureType.FullNamespace;
    if (!ns.StartsWith("System"))
    {
        if (!namespaces.Contains(ns)) { namespaces.Add(ns); }
    }
}
@foreach (var ns in namespaces.OrderBy(n => n))
{
    @:using @ns;
}

using static @(model.Namespace).@(model.Name);

namespace @(namespaceName).Models
{
    public partial class @(model.Name)DtoGen : GeneratedDto<@(model.FullName), @(model.Name)DtoGen>
        , IClassDto<@(model.FullName), @(model.Name)DtoGen>
        {
        public @(model.Name)DtoGen() { }

        @foreach (PropertyViewModel prop in model.ClientProperties)
        {
        @:public @prop.Type.NullableTypeForDto @prop.Name { get; set; }
        }

        // Create a new version of this object or use it from the lookup.
        public static @(model.Name)DtoGen Create(@(model.FullName) obj, IMappingContext context, IncludeTree tree = null) {
            if (obj == null) return null;
            var includes = context.Includes;
                        
            // Applicable includes for @(model.Name)
            @(model.DtoIncludesAsCS())

            // Applicable excludes for @(model.Name)
            @(model.DtoExcludesAsCS())

            // Applicable roles for @(model.Name)
            @(model.PropertyRolesAsCS())


            // See if the object is already created, but only if we aren't restricting by an includes tree.
            // If we do have an IncludeTree, we know the exact structure of our return data, so we don't need to worry about circular refs.
            if (tree == null && context.TryGetMapping(obj, out @(model.Name)DtoGen existing)) return existing; 

            var newObject = new @(model.Name)DtoGen();
            if (tree == null) context.AddMapping(obj, newObject);
            // Fill the properties of the object.
            @foreach (var prop in model.ClientProperties.OrderBy(p => p.PureType.HasClassViewModel))
            {
                @prop.ObjToDtoPropertySetter("newObject")
            }            
            return newObject;
        }

        // Instance constructor because there is no way to implement a static interface in C#. And generic constructors don't take arguments.
        public @(model.Name)DtoGen CreateInstance(@(model.FullName) obj, IMappingContext context, IncludeTree tree = null) {
            return Create(obj, context, tree);
        }

        // Updates an object from the database to the state handed in by the DTO.
        public void Update(@(model.FullName) entity, IMappingContext context)
        {
            var includes = context.Includes;

            if (OnUpdate(entity, context)) return;

            // Applicable includes for @(model.Name)
            @(model.DtoIncludesAsCS())

            // Applicable excludes for @(model.Name)
            @(model.DtoExcludesAsCS())

            // Applicable roles for @(model.Name)
            @(model.PropertyRolesAsCS())

            @foreach (var conditionGroup in model.ClientProperties
            .Where(p => p.IsClientWritable)
            .Select(p => p.DtoToObjPropertySetter())
            .Where(p => p != null)
            .GroupBy(s => s.Value.conditional))
            {
                if (!string.IsNullOrWhiteSpace(conditionGroup.Key))
                {
            @:if (@(conditionGroup.Key)) {
                @foreach (var setter in conditionGroup)
                {
                @:@(setter.Value.setter)
                }
            @:}
            }
            else
            {
            @foreach (var setter in conditionGroup)
            {
            @:@(setter.Value.setter)
            }
            }
            }
        }

	}
}
