@using IntelliTect.Coalesce.CodeGeneration.Templating.Razor;
@using IntelliTect.Coalesce.CodeGeneration.Knockout.Generators;
@using IntelliTect.Coalesce.TypeDefinition
@inherits CoalesceTemplate<ApiController>
@{
    ClassViewModel model = Model.Model;
    string namespaceName = Model.Namespace;
    if (!string.IsNullOrWhiteSpace(Model.AreaName))
    {
        namespaceName += "." + Model.AreaName;
    }
    var securityInfo = model.SecurityInfo;

    var namespaces = new List<string>();
    namespaces.Add("IntelliTect.Coalesce");
    namespaces.Add("IntelliTect.Coalesce.Api");
    namespaces.Add("IntelliTect.Coalesce.Data");
    namespaces.Add("IntelliTect.Coalesce.Mapping");
    namespaces.Add("IntelliTect.Coalesce.Mapping.IncludeTree");
    namespaces.Add("IntelliTect.Coalesce.Models");
    namespaces.Add("IntelliTect.Coalesce.TypeDefinition");
    namespaces.Add("Microsoft.AspNetCore.Authorization");
    namespaces.Add("Microsoft.AspNetCore.Mvc");
    namespaces.Add("System");
    namespaces.Add("System.Linq");
    namespaces.Add("System.Collections.Generic");
    namespaces.Add("System.ComponentModel.DataAnnotations");
    namespaces.Add("System.Net");
    namespaces.Add("System.Threading.Tasks");
    namespaces.Add($"{namespaceName}.Models");

    var createIf = "";
    var editElseIf = "";
    //var dataSourceParameter = $"IDataSource<{model.BaseViewModel.FullyQualifiedName}, {Model.GenerationContext.DbContextType.FullyQualifiedName}> dataSource";
    var dataSourceParameter = $"IDataSource<{model.BaseViewModel.FullyQualifiedName}> dataSource";


    // Check if creates/edits aren't allowed
    if (model.PrimaryKey.Type.IsString)
    {
        createIf = $"if (string.IsNullOrWhiteSpace(dto.{model.PrimaryKey.Name}) && !ClassViewModel.SecurityInfo.IsCreateAllowed(User)) {{";
        editElseIf = $"else if (!string.IsNullOrWhiteSpace(dto.{model.PrimaryKey.Name}) && !ClassViewModel.SecurityInfo.IsEditAllowed(User)) {{";
    }
    else if (model.IsDto)
    {
        createIf = $"if (dto.{model.PrimaryKey.Name} == 0 && !ClassViewModel.SecurityInfo.IsCreateAllowed(User)) {{";
        editElseIf = $"else if (dto.{model.PrimaryKey.Name} != 0 && !ClassViewModel.SecurityInfo.IsEditAllowed(User)) {{";
    }
    else
    {
        createIf = $"if (!dto.{model.PrimaryKey.Name}.HasValue && !ClassViewModel.SecurityInfo.IsCreateAllowed(User)) {{";
        editElseIf = $"else if (dto.{model.PrimaryKey.Name}.HasValue && !ClassViewModel.SecurityInfo.IsEditAllowed(User)) {{";
    }
}

@foreach (var ns in namespaces.Where(n => !string.IsNullOrEmpty(n)).OrderBy(n => n))
{
    @:using @ns;
}

namespace @(namespaceName).Api
{
@if (model.ApiRouted) {
    if (!string.IsNullOrWhiteSpace(Model.AreaName))
    {
    @:[Route("@Model.AreaName/api/[controller]")]
    }
    else
    {
    @:[Route("api/[controller]")]
    }
}
    @(securityInfo.ClassAnnotation)
    public partial class @(model.ApiControllerClassName)
    : LocalBaseApiController<@(model.BaseViewModel.FullyQualifiedName), @(model.DtoName)>
    {
        public @(model.ApiControllerClassName)(@Model.GenerationContext.DbContextType.FullyQualifiedName db) : base(db)
        {
        }

        @if (securityInfo.IsReadAllowed())
        {
        <text>
        [HttpGet("list")]
        @(securityInfo.ReadAnnotation)
        @(model.ApiActionAccessModifier) virtual Task<ListResult<@(model.DtoName)>> List(ListParameters parameters, @dataSourceParameter)
            => ListImplementation(parameters, dataSource);

        [HttpGet("count")]
        @(securityInfo.ReadAnnotation)
        @(model.ApiActionAccessModifier) virtual Task<int> Count(FilterParameters parameters, @dataSourceParameter)
            => CountImplementation(parameters, dataSource);

        [HttpGet("propertyValues")]
        @(securityInfo.ReadAnnotation)
        @(model.ApiActionAccessModifier) virtual IEnumerable<string> PropertyValues(string property, int page = 1, string search = "")
            => PropertyValuesImplementation(property, page, search);

        [HttpGet("get/{id}")]
        @(securityInfo.ReadAnnotation)
        @(model.ApiActionAccessModifier) virtual Task<@(model.DtoName)> Get(string id, DataSourceParameters parameters, @dataSourceParameter)
            => GetImplementation(id, parameters, dataSource);
        </text>
        }

        @if (securityInfo.IsDeleteAllowed()) {
        <text>
        [HttpPost("delete/{id}")]
        @(securityInfo.DeleteAnnotation)
        @(model.ApiActionAccessModifier) virtual bool Delete(string id)
            => DeleteImplementation(id);
        </text>
        }

        @if (securityInfo.IsCreateAllowed() || securityInfo.IsEditAllowed()) {
        <text>
        [HttpPost("save")]
        @(securityInfo.SaveAnnotation)
        @(model.ApiActionAccessModifier) virtual async Task<SaveResult<@(model.DtoName)>> Save(@(model.DtoName) dto, [FromQuery] DataSourceParameters parameters, @dataSourceParameter, bool returnObject = true)
        {

            @(createIf)
                var result = new SaveResult<@(model.DtoName)>("Create not allowed on @(model.Name) objects.");
                Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                return result;
            }
            @(editElseIf)
                var result = new SaveResult<@(model.DtoName)>("Edit not allowed on @(model.Name) objects.");
                Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                return result;
            }

            return await SaveImplementation(dto, parameters, dataSource, returnObject);
        }

        [HttpPost("AddToCollection")]
        @(securityInfo.EditAnnotation)
        @(model.ApiActionAccessModifier) virtual SaveResult<@(model.DtoName)> AddToCollection(int id, string propertyName, int childId)
        {
            return ChangeCollection(id, propertyName, childId, "Add");
        }
        [HttpPost("RemoveFromCollection")]
        @(securityInfo.EditAnnotation)
        @(model.ApiActionAccessModifier) virtual SaveResult<@(model.DtoName)> RemoveFromCollection(int id, string propertyName, int childId)
        {
            return ChangeCollection(id, propertyName, childId, "Remove");
        }
        </text>
        }

        /// <summary>
        /// Downloads CSV of @(model.DtoName)
        /// </summary>
        [HttpGet("csvDownload")]
        @(securityInfo.ReadAnnotation)
        @(model.ApiActionAccessModifier) virtual async Task<FileResult> CsvDownload(ListParameters parameters, @dataSourceParameter)
        {
            byte[] bytes = System.Text.Encoding.UTF8.GetBytes(await CsvText(parameters, dataSource));
            return File(bytes, "application/x-msdownload", "@(model.BaseViewModel.Name).csv");
        }

        /// <summary>
        /// Returns CSV text of @(model.DtoName)
        /// </summary>
        [HttpGet("csvText")]
        @(securityInfo.ReadAnnotation)
        @(model.ApiActionAccessModifier) virtual async Task<string> CsvText(ListParameters parameters, @dataSourceParameter)
        {
            var listResult = await ListImplementation(parameters, dataSource);
            return IntelliTect.Coalesce.Helpers.CsvHelper.CreateCsv(listResult.List);
        }

    
        @if (securityInfo.IsCreateAllowed() || securityInfo.IsEditAllowed())
        {
        <text>
        /// <summary>
        /// Saves CSV data as an uploaded file
        /// </summary>
        [HttpPost("CsvUpload")]
        @(securityInfo.SaveAnnotation)
        @(model.ApiActionAccessModifier) virtual async Task<IEnumerable<SaveResult<@(model.DtoName)>>> CsvUpload(Microsoft.AspNetCore.Http.IFormFile file, @dataSourceParameter, bool hasHeader = true) 
        {
            if (file == null || file.Length == 0) throw new ArgumentException("No files uploaded");

            using (var stream = file.OpenReadStream())
            {
                using (var reader = new System.IO.StreamReader(stream))
                {
                    var csv = reader.ReadToEnd();
                    return await CsvSave(csv, dataSource, hasHeader);
                }
            }
        }

        /// <summary>
        /// Saves CSV data as a posted string
        /// </summary>
        [HttpPost("CsvSave")]
        @(securityInfo.SaveAnnotation)
        @(model.ApiActionAccessModifier) virtual async Task<IEnumerable<SaveResult<@(model.DtoName)>>> CsvSave(string csv, @dataSourceParameter, bool hasHeader = true) 
        {
            // Get list from CSV
            var list = IntelliTect.Coalesce.Helpers.CsvHelper.ReadCsv<@(model.DtoName)>(csv, hasHeader);
            var resultList = new List<SaveResult<@(model.DtoName)>>();
            foreach (var dto in list){
                // Check if creates/edits aren't allowed
                @(createIf)
                    var result = new SaveResult<@(model.DtoName)>("Create not allowed on @(model.Name) objects.");
                    Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    resultList.Add(result);
                }
                @(editElseIf)
                    var result = new SaveResult<@(model.DtoName)>("Edit not allowed on @(model.Name) objects.");
                    Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    resultList.Add(result);
                }
                else {
                    var parameters = new DataSourceParameters() { Includes = "none" };
                    var result = await SaveImplementation(dto, parameters, dataSource, false);
                    resultList.Add(result);
                }
            }
            return resultList;
        }
        </text>
        }

        // Methods from data class exposed through API Controller.
        @foreach (var method in model.ClientMethods)
        {
            var returnType = $"SaveResult<{method.ReturnTypeNameForApi}>";
            if (!method.IsStatic) { returnType = $"async Task<{returnType}>"; }
        <text>
        /// <summary>
        /// Method: @method.Name
        /// </summary>
        [HttpPost("@(method.Name)")]
        @if (!string.IsNullOrEmpty(method.SecurityInfo.ExecuteAnnotation)) {
@:        @(method.SecurityInfo.ExecuteAnnotation)
        }
        @(model.ApiActionAccessModifier) virtual @returnType @method.Name (@method.CsParameters){
            @if (method.SecurityInfo.IsExecute) {
            @:if (!ClassViewModel.MethodByName("@method.Name").SecurityInfo.IsExecutable(User)) throw new Exception("Not authorized");
            }
            var result = new SaveResult<@method.ReturnTypeNameForApi>();
            try{
                @if (method.ReturnType.HasClassViewModel ||
                    (method.ReturnType.PureType.HasClassViewModel && method.ReturnType.IsCollection))
                {
                @:IncludeTree includeTree = null;
                }
                @if (method.IsStatic)
                {
                if(method.ReturnType.IsVoid){
                @:object objResult = null;
                @:@(method.Parent.FullyQualifiedName).@(method.Name)(@(method.CsArguments));
                }else{
@:var objResult = @(method.Parent.FullyQualifiedName).@(method.Name)(@(method.CsArguments));
                }
                }
                else
                {
                    // TODO: this is quite a hack (passing in empty ListParameters). Methods really need to accept IDataSourceParameters.
@:var (item, _) = await GetDataSource(new ListParameters()).GetItemAsync(id, new ListParameters());
                if (method.ReturnType.IsVoid)
                {
                @:object objResult = null;
                @:item.@(method.Name)(@(method.CsArguments));
                }else{
                @:var objResult = item.@(method.Name)(@(method.CsArguments));
                }
                @:Db.SaveChanges();
                }
        @if (method.ReturnType.IsCollection)
        {
            if (method.ReturnType.PureType.ClassViewModel?.IsDto ?? false)
            {
                @:result.Object = objResult.ToList();
            }
            else if (method.ReturnType.PureType.HasClassViewModel)
            {
                @:var mappingContext = new MappingContext(User, "");
                @:result.Object = objResult.ToList().Select(o => Mapper<@(method.ReturnType.PureType.ClassViewModel.FullyQualifiedName), @(method.ReturnType.PureType.ClassViewModel.DtoName)>.ObjToDtoMapper(o, mappingContext, (objResult as IQueryable)?.GetIncludeTree() ?? includeTree)).ToList();
            }
            else
            {
                @:result.Object = objResult;
            }
        }
        else
        {
            if (method.ReturnType.ClassViewModel?.IsDto ?? false)
            {
                @:result.Object = objResult;
            }
            else if (method.ReturnType.HasClassViewModel)
            {
                @:var mappingContext = new MappingContext(User, "");
                @:result.Object = Mapper<@(method.ReturnType.ClassViewModel.FullyQualifiedName), @(method.ReturnType.ClassViewModel.DtoName)>.ObjToDtoMapper(objResult, mappingContext, includeTree);
            }
            else
            {
                @:result.Object = objResult;
            }
        }

                result.WasSuccessful = true;
                result.Message = null;
            }catch(Exception ex){
                result.WasSuccessful = false;
                result.Message = ex.Message;
            }
            return result;
        }
</text>
        }
    }
}
